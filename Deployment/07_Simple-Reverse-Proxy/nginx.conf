# ===============================
# NGINX GLOBAL CONFIGURATION
# ===============================

# Automatically decide number of worker processes
# based on available CPU cores
worker_processes auto;

# NGINX worker runs as www-data (default on Ubuntu)
user www-data;

events {
    # Maximum simultaneous connections per worker
    worker_connections 1000;
}

http {
    # Load MIME types (helps browser understand file types)
    include mime.types;

    # Enable efficient file transfer
    sendfile on;

    # ===============================
    # FRONTEND REVERSE PROXY (React)
    # ===============================
    server {
        # NGINX listens on port 80 for this domain
        listen 127.0.0.1:80;

        # Domain for frontend
        server_name myapp.com;

        # Root directory for static files (error pages)
        root /var/www/client-folder;

        # Custom error page for client & upstream failures
        # Covers:
        # - 400: Bad Request
        # - 404: Not Found
        # - 500+: Server / Upstream errors
        error_page 400 404 500 502 503 504 /error.html;

        # Internal error page location
        # Prevents:
        # - Direct browser access
        # - Infinite proxy loops
        location = /error.html {
            internal;
        }

        # ===============================
        # REQUEST → RESPONSE FLOW
        # ===============================
        # 1. Browser sends request to myapp.com
        # 2. NGINX receives the request
        # 3. NGINX forwards it to React dev server (Vite)
        # 4. React server processes request
        # 5. Response flows back through NGINX to browser
        #
        # If React server is DOWN:
        # - NGINX receives 502 Bad Gateway
        # - proxy_intercept_errors catches it
        # - error_page serves /error.html locally
        location / {
            # Forward all requests to React dev server
            proxy_pass http://localhost:5173;

            # Allow NGINX to intercept upstream errors (502, 503, etc.)
            proxy_intercept_errors on;
        }
    }

    # ===============================
    # BACKEND REVERSE PROXY (Node.js API)
    # ===============================
    server {
        # Same port, different subdomain
        listen 127.0.0.1:80;

        # Domain for backend API
        server_name api.myapp.com;

        # Root directory for error pages
        root /var/www/client-folder;

        # Custom error handling for API failures
        error_page 400 404 500 502 503 504 /error.html;

        # Internal error page to avoid proxy recursion
        location = /error.html {
            internal;
        }

        # ===============================
        # REQUEST → RESPONSE FLOW
        # ===============================
        # 1. Client sends request to api.myapp.com
        # 2. NGINX receives the request
        # 3. NGINX forwards it to Node.js server
        # 4. Node.js processes API logic
        # 5. Response flows back through NGINX
        #
        # If Node server is DOWN:
        # - NGINX generates 502 Bad Gateway
        # - error_page returns custom error.html
        location / {
            # Forward API requests to Node.js backend
            proxy_pass http://localhost:4000;

            # Enable interception of upstream errors
            proxy_intercept_errors on;
        }
    }
}
